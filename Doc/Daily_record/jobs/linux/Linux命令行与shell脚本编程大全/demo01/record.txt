1: 将终端的背景色设置成被色,文本设置成黑色.
	setterm -inversescreen on./使用off可以关闭此特性.	
2: 查看系统上运行的所有进程.
	ps -ef	#-e:参数指定显示所有运行在系统上的进程
			#-f:参数则扩展了输出.
3: df查看磁盘的存储空间,du命令查看的是某个特定目录的磁盘使用情况.
	du命令的参数如下:
	-c: 显示所有已列出文件总的大小
	-h: 按用户易读的格式输出大小
	-s: 显示每个输出参数的总计
4. 要想将命令置入后台模式,可以在命令默默为加上字符&.
	jobs命令可以显示出当前运行在后台模式中的所有用户的进程.
5. 协程可以同时做两件事.它在后台生成一个子shell,并在这个子
	shell中执行命令.
	例子: coproc sleep 10
6. 命令历史记录被保存在隐藏文件.bash_history中,它位于用户的主目录中.
	这里要注意的是:bash命令的历史记录是先存放在内存中,当shell退出是
	才被写入到历史文件中.要实现强制写入,需要使用history命令-a选项.
	跨终端也可.但是对于其他打开的终端会话,历史记录并不会更新.
	这是因为.bash_history文件只有在代开收个终端会话时才会被读取.要
	想强制读取.bash_history文件.更新终端会话的历史记录,可以使用history
	-n 命令.
7. 所有的环境变量名均使用大写字母,这是bash shell的标准管理.如果
	是你自己创建的局部变量伙食shell脚本,请使用小写字母.变量名区
	分大小写.在涉及用户定义的局部变量时坚持使用小写字母,这能够
	便面重复定义系统环境变量可能带来的灾难.
8. 记住,变量名,等号和值之间没有空格,这一点非常重要.如果在赋值表达
	式中加了空格,bash shell就会把值当成一个单独的命令.
	例如: 
	$ my_variable = "Hello World" 
	-bash: my_variable: command not found
9. 顾名思义,局部环境变量只能在定义它们的进程中可见.子shell中定义的在
	父shell中不能使用,相反也一样.
10. 设置全局环境变量的方法是先创建一个局部环境变量,然后再把它导出
	到全局环境中.这个过程通过export命令来完成.变量名前面不需要加$.
11. 修改子shell中全局环境变量并不会影响到父shell中该变量的值,子shell
	甚至无法使用export命令改变父shell中全局环境变量的值.
12. 删除已经存在的环境变量,可以使用unset命令完成这个操作,记住不要使用$.
13. 在涉及环境变量时,什么时候该使用$,什么时候不该使用$,实在让人摸不
	着头脑.记住一点就行了: 如果要用到变量,使用$;如果要操作变量,不使用$.
	这条规则的一个例外就是使用printenv显示某个变量的值.	
14. 在处理全局环境变量时,事情就有点棘手了.如果你是在子进程中删除
	了一个全局环境变量,这只对子进程有效.该全局环境变量在父进程中
	依然可用.和修改变量一样,在子shell中删除全局变量后,你无法将效
	果反映到父shell中.
15. 环境变量可以作为数组使用:
	$ mytest=(one two three four five)
	$ echo $mytest 
	one
	$
	$ echo ${mytest[2]} 
	three
	$
16. useradd命令的系统默认值被设置在/etc/default/useradd文件中.
	useradd命令不会创建HOME目录,但是-m(home)命令行选项会使其
	创建HOME目录.
17. 如果你想从系统中删除用户,userdel可以满足这个需求.默认情况下,
	userdel命令只会删除/etc/passwd文件中的用户信息,而不会删除系
	统中属于该账户的任何文件.
18. 如果加上-r参数,userdel会删除用户HOME目录以及邮件目录.然后,系
	统上扔可能有已删除用户的其他文件.这在有些环境中会造成问题.
19. 在有大量用户的环境中使用-r参数时要特别小心.你永远不知道用户
	是否在其HOME目录下存放了其他用户或其他程序要使用的重要文件.
	记住,在删除用户的HOME目录之前一定要检查清除.
20. usermod命令:
	.-l修改用户账户的登陆名
	.-L锁定账户,使用户无法登陆
	.-p修改账户的密码.
	.-U解除锁定,使用户能够登陆
	-L选项尤其有用.它可以将账户锁定,使用户无法登陆,同时无需删除账户
	和用户数据.要让账户恢复正常,只要用-U选项就行了.
21. /etc/group文件有4个字段:
	.组名
	.组密码
	.GID
	.属于该组的用户列表
	千万不能通过直接修改/etc/group文件来添加用户到一个组,要通过usermod
	命令.在添加用户到不同组之前,首先得创建组.
	注意:用户账户列表某种意义上有些误导人.你会发现,在列表中,有些组
	并没有列出用户,这并不是说这些组没有成员.当一个用户在/etc/passwd
	文件中指定某个组作为默认组时,用户账户不会作为该组成员再出现在/etc
	/group文件中.
22. groupmod命令可以修改已有组的GID(加-g选项)或组名(加-n选项)
	修改组名时,GID和组成员不会改变,只有组名改变.由于所有的安全
	权限都是基于GID的,你可以随意改变组名而不会影响文件的安全性.
23. 使用文件权限符

	-rw-r--r--  1 develop  staff     0B Jul 21 09:32 file1
	输出结果的第一个字段就是描述文件和目录权限的编码.
	这个字段的第一个字符代表了对象的类型
		> -代表文件
		> d代表目录
		> l代表链接
		> c代表字符型设备
		> b代表块设备
		> n代表网络设备
		之后有3组三字符的编码.每一组定义了3种访问权限:
		> r代表对象是可读的
		> w代表对象是可写的
		> x代表对象是可执行的
		若没有某种权限,在该权限位会出现单破折线.这3组权限分别对应
		对象的3个安全级别:
		> 对象的属主
		> 对象的属组
		> 系统其它用户
	
24. 符号模式的权限设置:[ugoa] [+-=] [rwxXstugo...]
	第一组字符定义了权限作用的对象:
	> u代表用户
	> g代表组
	> o代表其他
	> a代表上述所有
	后面跟着的符号表示:
	> +在现有权限上增加权限
	> -在现有权限上移除权限
	> =将权限设置成后面的值
	第三个符号表示作用到设置上的权限(这个值要比通常的rwx多):
	> X:如果对象是目录或者它已有执行权限,赋予执行权限
	> s:运行时重新设置UID或GID
	> t:保留文件或目录
	> u:将权限设置为跟属主一样
	> g:将权限设置为跟属组一样
	> o:将权限设置为跟其他用户一样

25. ls命令的-F选项,它能够在具有执行权限的文件名后加一个星号.
	在目录后面加斜杠.
26. linux系统上共享文件的方法是创建组.
	
